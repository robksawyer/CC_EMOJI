package  {	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.DisplayObject;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.geom.Matrix;	import flash.display.PixelSnapping;		import flash.display.Loader;	import flash.events.Event;	import flash.events.IEventDispatcher;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.events.HTTPStatusEvent;	import flash.events.IOErrorEvent;	import flash.net.URLRequest;		import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;		//Logging	import com.demonsters.debugger.MonsterDebugger;		//import the Resolume communication classes	//make sure you have added the source path to these files in the ActionScript 3 Preferences of Flash	import resolumeCom.*;	import resolumeCom.parameters.*;	import resolumeCom.events.*;		public class EMOJI_GRID_PEOPLE_3 extends MovieClip 	{				/*****************TEST PARAMS********************/				private static var TESTING:Boolean = false;				/************************************************/						/*****************PRIVATE********************/		/**		* Create the resolume object that will do all the hard work for you.		*/		private var resolume:Resolume = new Resolume();				/**		* Examples of parameters that can be used inside of Resolume		*/		/*private var paramScaleX:FloatParameter = resolume.addFloatParameter("Scale X", 0.5);		private var paramScaleY:FloatParameter = resolume.addFloatParameter("Scale Y", 0.5);		private var paramRotate:FloatParameter = resolume.addFloatParameter("Rotate", 0.0);		private var paramFooter:StringParameter = resolume.addStringParameter("Footer", "VJ BOB");		private var paramShowBackground:BooleanParameter = resolume.addBooleanParameter("Background", true);		private var paramShowSurprise:EventParameter = resolume.addEventParameter("Surprise!");*/				private var emojisInfo:Object = {										keys: new Array(48, 64, 96),								   		sizes: new Array("48x48","64x64","96x96"),								  		total: new Number(10) //total number of emojis is 1363										};												//Hold the actual emoji bitmap references per size in separate arrays		private var emojis:Array = new Array();				//Holds the emojis		private var gridContainer:Sprite;				//Other Resolume Parameters		private var paramRandomize:EventParameter;		private var paramSingle:BooleanParameter;		private var paramRandScale:BooleanParameter;		private var paramFit:EventParameter;		private var paramScale:FloatParameter;		private var paramGap:FloatParameter;				public static var EMOJI_INIT_SIZE:int = 96;		public var EMOJI_SIZE:int = 96;				private var globalScaleVal:Number = 0.5;				private var scaledEmojis:Array = new Array();				private var firstLoad:Boolean = true;				public function EMOJI_GRID_PEOPLE_3():void		{			stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;						// Start the MonsterDebugger			MonsterDebugger.initialize(this);						initData();						//Initialize the Resolume parameters			initParams();						//set callback, this will notify us when a parameter has changed			resolume.addParameterListener(paramChanged);						addEventListener(Event.ADDED_TO_STAGE, init);		}				/**		* Initialize data 		* - initialize all of the emojis bitmaps that are used in the plugin		*/		private function initData()		{						emojis = [				{				  name: "Yellow Angel",				  id: 884,				  bitmap48: new Bitmap( new Emoji_48x48_884() ),				  bitmap96: new Bitmap( new Emoji_96x96_884() )				},				{				  name: "Whiter Angel",				  id: 885,				  bitmap48: new Bitmap( new Emoji_48x48_885() ),				  bitmap96: new Bitmap( new Emoji_96x96_885() )				},				{				  name: "White Angel",				  id: 886,				  bitmap48: new Bitmap( new Emoji_48x48_886() ),				  bitmap96: new Bitmap( new Emoji_96x96_886() )				},				{				  name: "Tan Angel",				  id: 887,				  bitmap48: new Bitmap( new Emoji_48x48_887() ),				  bitmap96: new Bitmap( new Emoji_96x96_887() )				},				{				  name: "Brown Angel",				  id: 888,				  bitmap48: new Bitmap( new Emoji_48x48_888() ),				  bitmap96: new Bitmap( new Emoji_96x96_888() )				},				{				  name: "Black Angel",				  id: 889,				  bitmap48: new Bitmap( new Emoji_48x48_889() ),				  bitmap96: new Bitmap( new Emoji_96x96_889() )				},				{				  name: "Yellow Info Lady",				  id: 894,				  bitmap48: new Bitmap( new Emoji_48x48_894() ),				  bitmap96: new Bitmap( new Emoji_96x96_894() )				},				{				  name: "Whiter Info Lady",				  id: 895,				  bitmap48: new Bitmap( new Emoji_48x48_895() ),				  bitmap96: new Bitmap( new Emoji_96x96_895() )				},				{				  name: "White Info Lady",				  id: 896,				  bitmap48: new Bitmap( new Emoji_48x48_896() ),				  bitmap96: new Bitmap( new Emoji_96x96_896() )				},				{				  name: "Tan Info Lady",				  id: 897,				  bitmap48: new Bitmap( new Emoji_48x48_897() ),				  bitmap96: new Bitmap( new Emoji_96x96_897() )				},				{				  name: "Brown Info Lady",				  id: 898,				  bitmap48: new Bitmap( new Emoji_48x48_898() ),				  bitmap96: new Bitmap( new Emoji_96x96_898() )				},				{				  name: "Black Info Lady",				  id: 899,				  bitmap48: new Bitmap( new Emoji_48x48_899() ),				  bitmap96: new Bitmap( new Emoji_96x96_899() )				},				{				  name: "Yellow Guardsman",				  id: 900,				  bitmap48: new Bitmap( new Emoji_48x48_900() ),				  bitmap96: new Bitmap( new Emoji_96x96_900() )				},				{				  name: "Whiter Guardsman",				  id: 901,				  bitmap48: new Bitmap( new Emoji_48x48_901() ),				  bitmap96: new Bitmap( new Emoji_96x96_901() )				},				{				  name: "White Guardsman",				  id: 902,				  bitmap48: new Bitmap( new Emoji_48x48_902() ),				  bitmap96: new Bitmap( new Emoji_96x96_902() )				},				{				  name: "Tan Guardsman",				  id: 903,				  bitmap48: new Bitmap( new Emoji_48x48_903() ),				  bitmap96: new Bitmap( new Emoji_96x96_903() )				},				{				  name: "Brown Guardsman",				  id: 904,				  bitmap48: new Bitmap( new Emoji_48x48_904() ),				  bitmap96: new Bitmap( new Emoji_96x96_904() )				},				{				  name: "Black Guardsman",				  id: 905,				  bitmap48: new Bitmap( new Emoji_48x48_905() ),				  bitmap96: new Bitmap( new Emoji_96x96_905() )				},				{				  name: "Yellow Dancer",				  id: 906,				  bitmap48: new Bitmap( new Emoji_48x48_906() ),				  bitmap96: new Bitmap( new Emoji_96x96_906() )				},				{				  name: "Whiter Dancer",				  id: 907,				  bitmap48: new Bitmap( new Emoji_48x48_907() ),				  bitmap96: new Bitmap( new Emoji_96x96_907() )				},				{				  name: "White Dancer",				  id: 908,				  bitmap48: new Bitmap( new Emoji_48x48_908() ),				  bitmap96: new Bitmap( new Emoji_96x96_908() )				},				{				  name: "Tan Dancer",				  id: 909,				  bitmap48: new Bitmap( new Emoji_48x48_909() ),				  bitmap96: new Bitmap( new Emoji_96x96_909() )				},				{				  name: "Brown Dancer",				  id: 910,				  bitmap48: new Bitmap( new Emoji_48x48_910() ),				  bitmap96: new Bitmap( new Emoji_96x96_910() )				},				{				  name: "Black Dancer",				  id: 911,				  bitmap48: new Bitmap( new Emoji_48x48_911() ),				  bitmap96: new Bitmap( new Emoji_96x96_911() )				},				{				  name: "Yellow Massage",				  id: 919,				  bitmap48: new Bitmap( new Emoji_48x48_919() ),				  bitmap96: new Bitmap( new Emoji_96x96_919() )				},				{				  name: "Whiter Massage",				  id: 920,				  bitmap48: new Bitmap( new Emoji_48x48_920() ),				  bitmap96: new Bitmap( new Emoji_96x96_920() )				},				{				  name: "White Massage",				  id: 921,				  bitmap48: new Bitmap( new Emoji_48x48_921() ),				  bitmap96: new Bitmap( new Emoji_96x96_921() )				},				{				  name: "Tan Massage",				  id: 922,				  bitmap48: new Bitmap( new Emoji_48x48_922() ),				  bitmap96: new Bitmap( new Emoji_96x96_922() )				},				{				  name: "Brown Massage",				  id: 923,				  bitmap48: new Bitmap( new Emoji_48x48_923() ),				  bitmap96: new Bitmap( new Emoji_96x96_923() )				},				{				  name: "Black Massage",				  id: 924,				  bitmap48: new Bitmap( new Emoji_48x48_924() ),				  bitmap96: new Bitmap( new Emoji_96x96_924() )				},				{				  name: "Yellow Haircut",				  id: 925,				  bitmap48: new Bitmap( new Emoji_48x48_925() ),				  bitmap96: new Bitmap( new Emoji_96x96_925() )				},				{				  name: "Whiter Haircut",				  id: 926,				  bitmap48: new Bitmap( new Emoji_48x48_926() ),				  bitmap96: new Bitmap( new Emoji_96x96_926() )				},				{				  name: "White Haircut",				  id: 927,				  bitmap48: new Bitmap( new Emoji_48x48_927() ),				  bitmap96: new Bitmap( new Emoji_96x96_927() )				},				{				  name: "Tan Haircut",				  id: 928,				  bitmap48: new Bitmap( new Emoji_48x48_928() ),				  bitmap96: new Bitmap( new Emoji_96x96_928() )				},				{				  name: "Brown Haircut",				  id: 929,				  bitmap48: new Bitmap( new Emoji_48x48_929() ),				  bitmap96: new Bitmap( new Emoji_96x96_929() )				},				{				  name: "Black Haircut",				  id: 930,				  bitmap48: new Bitmap( new Emoji_48x48_930() ),				  bitmap96: new Bitmap( new Emoji_96x96_930() )				},				{				  name: "Yellow Boy and Girl Kiss",				  id: 938,				  bitmap48: new Bitmap( new Emoji_48x48_938() ),				  bitmap96: new Bitmap( new Emoji_96x96_938() )				},				{				  name: "Yellow Boy and Boy Kiss",				  id: 939,				  bitmap48: new Bitmap( new Emoji_48x48_939() ),				  bitmap96: new Bitmap( new Emoji_96x96_939() )				},				{				  name: "Yellow Girl and Girl Kiss",				  id: 940,				  bitmap48: new Bitmap( new Emoji_48x48_940() ),				  bitmap96: new Bitmap( new Emoji_96x96_940() )				},				{				  name: "Yellow Girl and Boy Heart",				  id: 942,				  bitmap48: new Bitmap( new Emoji_48x48_942() ),				  bitmap96: new Bitmap( new Emoji_96x96_942() )				},				{				  name: "Yellow Boy and Boy Heart",				  id: 943,				  bitmap48: new Bitmap( new Emoji_48x48_943() ),				  bitmap96: new Bitmap( new Emoji_96x96_943() )				},				{				  name: "Yellow Girl and Girl Heart",				  id: 944,				  bitmap48: new Bitmap( new Emoji_48x48_944() ),				  bitmap96: new Bitmap( new Emoji_96x96_944() )				}			];		}				/**			* Initialize parameters that are used inside of Resolume		*/		public function initParams():void		{			MonsterDebugger.trace(this, "Iniailizing Resolume parameters.", "Init Phase");						if(TESTING)			{				//emojis[0].param = resolume.addBooleanParameter(emojis[0].name, true);				//emojis[0].activated = false;			}			else			{				//Booleans				/*for(var i=0;i<emojis.length;i++)				{					emojis[i].param = resolume.addBooleanParameter(emojis[i].name, false);					emojis[i].activated = false;				}*/			}						paramRandomize = resolume.addEventParameter("Randomize");			paramFit = resolume.addEventParameter("Fit Aspect Ratio");			//			paramSingle = resolume.addBooleanParameter("Single Emoji", false);			//paramRandScale = resolume.addBooleanParameter("Random Scale", true);			//			paramScale = resolume.addFloatParameter("Emoji Scale", 0.5); //96px is the default			paramGap = resolume.addFloatParameter("Spacing", 0.0);		}			/**			* Main initialize method		*/		public function init( e:Event ):void		{			MonsterDebugger.trace(this, "EMOJI Initialized", "Init Phase");						//Build the grid			buildGrid();						if(TESTING)			{							}		}							/**		* This method will be called everytime you change a paramater in Resolume.		*/		public function paramChanged( event:ChangeEvent ):void 		{			MonsterDebugger.trace(this, "Param Changed: " + event.object, "Interactive Phase");			//Check to see if the param was a Boolean			switch(event.object)			{				case paramRandomize:					resetGrid();					break;								case paramSingle:					updateGrid();					break;									case paramGap:					updateGrid();					break;								case paramScale:					EMOJI_SIZE = EMOJI_INIT_SIZE;					if(paramScale.getValue() > 0.3)					{						globalScaleVal = paramScale.getValue();					}					else					{						globalScaleVal = 0.3;						paramScale.setValue(0.3);					}					updateGrid();					break;									case paramFit:					EMOJI_SIZE = EMOJI_INIT_SIZE;					var scaleVal:Number = 0.5;					var gap:Number = paramGap.getValue();					var gcdScaleRatio = getGreatestCommonFactor( (EMOJI_SIZE * scaleVal) + (gap/2), stage.stageWidth, stage.stageHeight);					EMOJI_SIZE = gcdScaleRatio;					buildGrid(scaleVal, false, gcdScaleRatio);					break;									case paramRandScale:					/*if(paramRandScale.getValue() == true)					{						scaleEmoji(true);					}*/					break;									default:					MonsterDebugger.trace(this, event.object);					break;			}		}				/**		* Updates the grid with a new number of icons		*/		private function updateGrid():void		{			buildGrid( globalScaleVal  );		}				/**		* Resets the grid of icons		*/		private function resetGrid():void		{			/*if(contains(gridContainer))			{				removeChild(gridContainer);			}*/			buildGrid( globalScaleVal , true );		}				/**		* Handles scaling a single emoji		*/		private function scaleEmoji(rand:Boolean = false, instanceNum:Number = 0):void		{			var scaleVal:Number = EMOJI_SIZE * globalScaleVal;			var emojiIndex = 0;			var randInstance = randRange(0, gridContainer.numChildren - 1);			var stageRef:DisplayObject;						if(rand)			{				stageRef = randomEmoji();				emojiIndex = stageRef.name;			}			else			{				stageRef = gridContainer.getChildAt(instanceNum);				if(!stageRef)				{					return;				}				emojiIndex = stageRef.name;			}						if(typeof(scaledEmojis[emojiIndex]) != "object")			{				scaledEmojis[emojiIndex] = new Object();			}						if (stageRef != null) 			{				//Save the reference				scaledEmojis[emojiIndex].bitmap = stageRef;								//Remove the previous instance				gridContainer.removeChildAt(randInstance);								if(scaledEmojis[emojiIndex].isScaled)				{					scaledEmojis[emojiIndex].bitmap.width = EMOJI_SIZE;					scaledEmojis[emojiIndex].bitmap.height = EMOJI_SIZE;					scaledEmojis[emojiIndex].isScaled = false;				}				else 				{					scaledEmojis[emojiIndex].bitmap.width = scaleVal;					scaledEmojis[emojiIndex].bitmap.height = scaleVal;					scaledEmojis[emojiIndex].isScaled = true;				}				gridContainer.addChild( scaledEmojis[emojiIndex].bitmap );			}		}				/**		* Builds a grid of icons		*/		private function buildGrid(scaleVal:Number = 0.5, reset:Boolean = false, gcdScaleRatio:Number = 0.0):void		{			MonsterDebugger.trace(this, "Building grid...", "Action Phase");						// current column			var column:int = 0;			// current row			var row:int = 0;			// distance between objects			var gap:Number = 0;			if(paramGap.getValue() > 0)			{				gap = paramGap.getValue() * 50;			}						var x_counter:Number = 0;			var y_counter:Number = 0;						if(gcdScaleRatio == 0.0)			{				gcdScaleRatio = EMOJI_SIZE * scaleVal;			}						var scaledEmojiSize = gcdScaleRatio;			var totalCols:int = Math.ceil(stage.stageWidth / scaledEmojiSize);			var totalRows:int = Math.ceil(stage.stageHeight / scaledEmojiSize);						var totalIcons:int = Math.ceil(totalCols * totalRows);						MonsterDebugger.trace(this, "New emoji size: " + scaledEmojiSize, "Testing");			MonsterDebugger.trace(this, "Total rows: " + totalRows, "Testing");			MonsterDebugger.trace(this, "Total cols: " + totalCols, "Testing");			MonsterDebugger.trace(this, "Total icons: " + totalIcons, "Testing");						// Sprite that holds grid			if(firstLoad)			{				gridContainer = new Sprite();			}						//Holds the icon			var cell:Bitmap;			if( paramSingle.getValue() == true && !firstLoad){				var randInstance = randRange(0, gridContainer.numChildren - 1);				var stageRef = gridContainer.getChildAt(randInstance);				if(!stageRef || reset == true)				{					cell = randomEmoji();				}				else				{					cell = stageRef;				}			}						if(contains(gridContainer) && !firstLoad)			{				removeChild(gridContainer);				gridContainer = new Sprite();			}						for (var i:int = 0; i < totalIcons; i++) {				//column = i % totalRows;				//row = int(i / totalCols);				// get corresponding object from the array				if( paramSingle.getValue() == false)				{					cell = new Bitmap( randomEmoji().bitmapData, PixelSnapping.NEVER );				}				else				{					cell = new Bitmap(cell.bitmapData, PixelSnapping.NEVER);				}								if(i>0)				{					if (x_counter+1 < totalCols)					{						x_counter++;					} 					else 					{						x_counter = 0;						y_counter++;					}				}								cell.width = gcdScaleRatio;				cell.height = gcdScaleRatio;				cell.smoothing = true;				cell.x = (cell.width + gap) * x_counter;				cell.y = (cell.height + gap) * y_counter;								//Render the emoji				gridContainer.addChild(cell);								MonsterDebugger.trace(this,i + "\tcolumn = " + column + "\trow = " + row, "Testing");			}						//Render the grid 			//gridContainer.x = gridContainer.y = 20;			addChild(gridContainer);			firstLoad = false;		}						/**			* Returns a random emoji		*/		public function randomEmoji():Bitmap		{			var rand:Number = randRange(0, emojis.length-1);			MonsterDebugger.trace(this, "Random #" + rand, "Testing");			if(!emojis[rand]){				MonsterDebugger.trace(this, "Unable to load Emoji #" + rand, "Testing");			}			return emojis[rand]["bitmap"+EMOJI_INIT_SIZE];		}				/**		* Finds the class name of an object and creates an object based on a class's String-formated name.		* Source: https://delfeld.wordpress.com/2009/04/21/object_from_class_name/		*/		public function getClassObj(obj:*):*		{			var objClass:Class = Class(getDefinitionByName(getQualifiedClassName(obj)));			return new objClass();		}				private function randRange(minNum:Number, maxNum:Number):Number 		{			return (Math.floor(Math.random() * (maxNum - minNum + 1)) + minNum);		}						/**		* http://snipplr.com/view.php?codeview&id=33076		*/		public function getGreatestCommonFactor( e1:uint, e2:uint, e3:uint ):uint{			var elements = new Array( e1, e2, e3 );			var gcd:uint;								var factors:Array = new Array();			var cnt:uint=0;			var qCnt:uint=0;			var elementCount:uint=elements.length;								//find the min number			var minNum:uint = Math.min ( elements[0], elements[1], elements[2] );			trace("Min num: " + minNum);								//loop thru all values of min from 1			for(var i=1;i<=minNum;i++){										//test for remainder for all 3				for(var k=0;k<elements.length;k++){					if(elements[k]%i==0){						cnt++;					}				}				//if can be div by all 3				if(cnt==elements.length){					trace("Factor found");					factors[qCnt]=i;					qCnt++;				}					cnt=0;			}								//Find the greatest factor			for( i=0;i<qCnt;i++){				if(gcd<factors[i]){					gcd=factors[i];				}			}								trace( "Factors: " + factors );			return gcd;		}	}}